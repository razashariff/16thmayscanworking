import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "@/components/ui/use-toast";
import { Shield, ShieldAlert, Loader, CheckCircle } from "lucide-react";
import Navbar from "@/components/Navbar";
import Footer from "@/components/Footer";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Progress } from "@/components/ui/progress";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Tables } from "@/integrations/supabase/types";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Card } from "@/components/ui/card";
import DownloadPdfButton from "../components/DownloadPdfButton";

type VulnerabilityScan = Tables<"vulnerability_scans">;

interface VulnerabilitySummary {
  high?: unknown[];
  medium?: unknown[];
  low?: unknown[];
  informational?: unknown[];
}

import { User } from "@supabase/supabase-js";

const VulnerabilityScanner = () => {
  const navigate = useNavigate();
  const [url, setUrl] = useState("");
  const [savedUrls, setSavedUrls] = useState<string[]>([]);
  const [selectedUrl, setSelectedUrl] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isCheckingStatus, setIsCheckingStatus] = useState(false);
  const [user, setUser] = useState<User | null>(null);
  const [completedScans, setCompletedScans] = useState<VulnerabilityScan[]>([]);
  const [currentScanId, setCurrentScanId] = useState<string | null>(null);
  const [currentScanStatus, setCurrentScanStatus] = useState<string | null>(
    null,
  );
  const [scanProgress, setScanProgress] = useState<number>(0);
  const [scanVulnCounts, setScanVulnCounts] = useState<{
    [scanId: string]: {
      high: number;
      medium: number;
      low: number;
      informational: number;
      total: number;
    };
  }>({});

  useEffect(() => {
    const getUser = async () => {
      const { data } = await supabase.auth.getSession();
      if (!data.session) {
        toast({
          variant: "destructive",
          title: "Authentication Required",
          description: "Please log in to use the vulnerability scanner",
        });
        navigate("/auth");
        return;
      }
      setUser(data.session.user);
    };
    getUser();
  }, [navigate]);

  useEffect(() => {
    if (!user) return;

    // Fetch completed scans and saved URLs
    const fetchData = async () => {
      // 1. List all files in scans/ before requesting scans
      const { data: fileList, error: listError } = await supabase.storage
        .from("scan_reports")
        .list("scans/");
      const availableFileNames = (fileList || []).map(f => f.name);

      // Fetch latest scans (any status, limit 10)
      const { data: allScans, error: scansError } = await supabase
        .from("vulnerability_scans")
        .select("*")
        .eq("user_id", user.id)
        .order("updated_at", { ascending: false })
        .limit(10);

      if (scansError) {
        console.error("Error fetching scans:", scansError);
        toast({
          variant: "destructive",
          title: "Error",
          description: "Failed to load scans",
        });
      } else {
        // Filter: Only scans with a matching file in storage
        const filteredScans = (allScans || []).filter(scan => {
          let reportPath = scan.report_path;
          if (!reportPath) {
            if (scan.created_at) {
              // Format: scans/scan-YYYY-MM-DDTHH-MM-SS-SSSZ.json
              const match = scan.created_at.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{1,})/);
              if (match) {
                const [, yyyy, MM, dd, HH, mm, ss, msRaw] = match;
                const ms = msRaw.substring(0, 3).padEnd(3, "0");
                reportPath = `scans/scan-${yyyy}-${MM}-${dd}T${HH}-${mm}-${ss}-${ms}Z.json`;
              } else {
                // fallback to scans/scan-<id>.json
                reportPath = `scans/scan-${scan.id}.json`;
              }
            } else {
              reportPath = `scans/scan-${scan.id}.json`;
            }
          }
          // Remove 'scans/' prefix for matching
          const fileName = reportPath.replace(/^scans\//, '');
          return availableFileNames.includes(fileName);
        });
        setCompletedScans(filteredScans);
      }

      // Fetch saved URLs from previous scans
      const { data: urlsData, error: urlsError } = await supabase
        .from("vulnerability_scans")
        .select("target_url")
        .eq("user_id", user.id)
        .order("created_at", { ascending: false });

      if (urlsError) {
        console.error("Error fetching saved URLs:", urlsError);
      } else {
        // Extract unique URLs
        const uniqueUrls = [
          ...new Set(urlsData?.map((item) => item.target_url) || []),
        ];
        setSavedUrls(uniqueUrls.slice(0, 3)); // Limit to 3 URLs
      }
    };

    fetchData();

    const channel = supabase
      .channel("scan-updates")
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "vulnerability_scans",
          filter: `user_id=eq.${user.id}`,
        },
        (payload) => {
          console.log("Scan updated:", payload);
          // If this is our current scan, update its status
          if (payload.new.id === currentScanId) {
            setCurrentScanStatus(payload.new.status);
            setScanProgress(payload.new.progress || 0);

            // If completed or failed, refresh the list of completed scans
            if (
              payload.new.status === "completed" ||
              payload.new.status === "failed"
            ) {
              fetchCompletedScans();
            }
          }
        },
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [user, currentScanId]);

  useEffect(() => {
    // After completedScans are fetched, get vulnerability counts for each scan
    async function fetchVulnCounts() {
      const counts: {
        [scanId: string]: {
          high: number;
          medium: number;
          low: number;
          informational: number;
          total: number;
        };
      } = {};
      for (const scan of completedScans) {
        try {
          // Helper to format ISO timestamp to match your storage filenames (scan-YYYY-MM-DDTHH-MM-SS-SSSZ.json)
          function formatTimestampForFilename(isoString: string) {
            // Example: 2025-05-15T16:02:37.321+00:00 â†’ scan-2025-05-15T16-02-37-321Z.json
            const match = isoString.match(
              /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{1,})/,
            );
            if (match) {
              const [, yyyy, MM, dd, HH, mm, ss, msRaw] = match;
              // Always take the first 3 digits for milliseconds, pad with zeros if needed
              const ms = msRaw.substring(0, 3).padEnd(3, "0");
              return `${yyyy}-${MM}-${dd}T${HH}-${mm}-${ss}-${ms}Z`;
            } else {
              // fallback to JS Date (may not match exactly)
              const d = new Date(isoString);
              const pad = (n: number, z = 2) => n.toString().padStart(z, "0");
              return `${d.getUTCFullYear()}-${pad(d.getUTCMonth() + 1)}-${pad(d.getUTCDate())}T${pad(d.getUTCHours())}-${pad(d.getUTCMinutes())}-${pad(d.getUTCSeconds())}-${d.getUTCMilliseconds().toString().padStart(3, "0")}Z`;
            }
          }

          // 1. List all files in scans/ before requesting signed URL
          const { data: fileList, error: listError } = await supabase.storage
            .from("scan_reports")
            .list("scans/");
          if (listError) {
            console.error("List error:", listError.message);
          } else {
            console.log("Files in scans/:", fileList?.map(f => f.name));
          }

          // 2. Log the exact reportPath being requested
          const reportPath = scan.report_path ||
            (scan.created_at
              ? `scans/scan-${formatTimestampForFilename(scan.created_at)}.json`
              : `scans/scan-${scan.id}.json`);
          console.log("Requesting signed URL for path:", reportPath);

          // 3. Only request signed URL if file exists
          const existingFiles = (fileList || []).map(f => f.name);
          const requestedFile = reportPath.replace(/^scans\//, '');
          if (existingFiles.includes(requestedFile)) {
            const { data: signedData, error: signedError } = await supabase.storage
              .from("scan_reports")
              .createSignedUrl(reportPath, 60);
            if (signedError || !signedData?.signedUrl) {
              console.error("Signed URL error:", signedError?.message, "Available files:", fileList?.map(f => f.name));
              counts[scan.id] = {
                high: 0,
                medium: 0,
                low: 0,
                informational: 0,
                total: 0,
              };
              continue;
            }
            const resp = await fetch(signedData.signedUrl);
            const json = await resp.json();
            const alerts = json.site?.[0]?.alerts || [];

            let high = 0,
              medium = 0,
              low = 0,
              informational = 0;
            alerts.forEach((alert: { riskdesc?: string }) => {
              const risk = (alert.riskdesc || "").toLowerCase();
              if (risk.startsWith("high")) high++;
              else if (risk.startsWith("medium")) medium++;
              else if (risk.startsWith("low")) low++;
              else if (risk.startsWith("informational")) informational++;
            });
            counts[scan.id] = {
              high,
              medium,
              low,
              informational,
              total: high + medium + low + informational,
            };
          } else {
            console.warn('Requested file does not exist in Storage:', requestedFile);
            counts[scan.id] = {
              high: 0,
              medium: 0,
              low: 0,
              informational: 0,
              total: 0,
            };
          }

          let high = 0,
            medium = 0,
            low = 0,
            informational = 0;
          alerts.forEach((alert: { riskdesc?: string }) => {
            const risk = (alert.riskdesc || "").toLowerCase();
            if (risk.startsWith("high")) high++;
            else if (risk.startsWith("medium")) medium++;
            else if (risk.startsWith("low")) low++;
            else if (risk.startsWith("informational")) informational++;
          });

          counts[scan.id] = {
            high,
            medium,
            low,
            informational,
            total: alerts.length,
          };
        } catch (e) {
          counts[scan.id] = {
            high: 0,
            medium: 0,
            low: 0,
            informational: 0,
            total: 0,
          };
        }
      }
      setScanVulnCounts(counts);
    }

    if (completedScans.length) {
      fetchVulnCounts();
    }
  }, [completedScans]);

  // Function to fetch completed scans
  const fetchCompletedScans = async () => {
    if (!user) return;

    const { data, error } = await supabase
      .from("vulnerability_scans")
      .select("*")
      .eq("user_id", user.id)
      .eq("status", "completed")
      .order("completed_at", { ascending: false });

    if (error) {
      console.error("Error fetching completed scans:", error);
    } else {
      setCompletedScans(data || []);
    }
  };

  // Function to check scan status manually (not auto-polling)
  const checkScanStatus = async () => {
    if (!currentScanId || !user) return;

    try {
      setIsCheckingStatus(true);

      console.log(`Manually checking status for scan ${currentScanId}`);

      // Use GET request with scan_id as URL parameter
      const url = `zap-scan?scan_id=${encodeURIComponent(currentScanId)}`;
      const { data, error } = await supabase.functions.invoke(url, {
        method: "GET",
        headers: { "Content-Type": "application/json" },
      });

      if (error) {
        console.error("Error checking scan status:", error);
        toast({
          variant: "destructive",
          title: "Error",
          description: "Could not check scan status. Please try again.",
        });
        return;
      }

      if (data) {
        console.log("Scan status response:", data);
        setCurrentScanStatus(data.status);
        setScanProgress(data.progress || 0);

        if (data.status === "completed") {
          toast({
            title: "Scan Completed",
            description: "Vulnerability scan completed successfully!",
          });
          fetchCompletedScans();
          setCurrentScanId(null);
          setCurrentScanStatus(null);
        } else if (data.status === "failed") {
          toast({
            variant: "destructive",
            title: "Scan Failed",
            description: data.error || "An error occurred during the scan",
          });
          setCurrentScanId(null);
          setCurrentScanStatus(null);
        }
      }
    } catch (error) {
      console.error("Error in checkScanStatus:", error);
    } finally {
      setIsCheckingStatus(false);
    }
  };

  const viewScanDetails = (scanId: string) => {
    const scan = completedScans.find((s) => s.id === scanId);
    if (!scan) return;
    let scanIdentifier = "";
    if (scan.report_path) {
      // Extract the scanId from the filename (removes scan- prefix and .json suffix)
      const match = scan.report_path.match(/scan-(.+)\.json$/);
      if (match) {
        scanIdentifier = match[1];
      }
    }
    // Fallback to old logic if report_path is missing
    if (!scanIdentifier && scan.created_at) {
      const isoString = scan.created_at;
      const isoMatch = isoString.match(
        /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{1,})/,
      );
      if (isoMatch) {
        const [, yyyy, MM, dd, HH, mm, ss, msRaw] = isoMatch;
        const ms = msRaw.substring(0, 3).padEnd(3, "0");
        scanIdentifier = `${yyyy}-${MM}-${dd}T${HH}-${mm}-${ss}-${ms}Z`;
      } else {
        const d = new Date(isoString);
        const pad = (n: number, z = 2) => n.toString().padStart(z, "0");
        scanIdentifier = `${d.getUTCFullYear()}-${pad(d.getUTCMonth() + 1)}-${pad(d.getUTCDate())}T${pad(d.getUTCHours())}-${pad(d.getUTCMinutes())}-${pad(d.getUTCSeconds())}-${d.getUTCMilliseconds().toString().padStart(3, "0")}Z`;
      }
    }
    if (!scanIdentifier) scanIdentifier = scanId;
    navigate(`/report/${scanIdentifier}`);
  };

  // --- Debug and Cleanup Features ---
  // List all available scan report files in storage (scans/ folder)
  const [storageFiles, setStorageFiles] = useState<string[]>([]);
  const [cleanupResults, setCleanupResults] = useState<string[]>([]);
  const [showCleanup, setShowCleanup] = useState(false);
  const fetchStorageFiles = async () => {
    try {
      const { data, error } = await supabase.storage.from('scan_reports').list('scans/', { limit: 200 });
      if (error) {
        setStorageFiles([`Error: ${error.message}`]);
        return;
      }
      setStorageFiles((data || []).map(f => f.name));
    } catch (error) {
      console.error("Error fetching storage files:", error);
      setStorageFiles([`Error: ${error.message}`]);
    }
  };


// ... (rest of the code remains the same)

const startScan = async () => {
  setIsLoading(true);

  const scanUrl = selectedUrl || url;
  if (!scanUrl || !/^https?:\/\//i.test(scanUrl)) {
    toast({
      variant: "destructive",
      title: "Invalid URL",
      description: "Please enter a valid URL starting with http:// or https://.",
    });
    setIsLoading(false);
    return;
  }

  // Generate a unique scan_id for this scan
  const scan_id = (window.crypto && window.crypto.randomUUID) ? window.crypto.randomUUID() : Date.now().toString();
  const payload = { target_url: scanUrl, scan_id };
  console.log("Sending payload to edge function:", payload);

  try {
    // Send the request to the Edge Function using fetch directly
    const response = await fetch(
      "https://jjdzrxfriezvfxjacche.supabase.co/functions/v1/zap-scan",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${(await supabase.auth.getSession()).data.session?.access_token}`,
          apikey:
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpqZHpyeGZyaWV6dmZ4amFjY2hlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ4ODIyMjcsImV4cCI6MjA2MDQ1ODIyN30.gx3n1fKedtU4s4OqKIqPWvUlBQzajOz80rJit1STFwY",
        },
        body: JSON.stringify(payload),
      },
    );

    if (!response.ok) {
      const errorText = await response.text();
      const errorMessage = `HTTP error! status: ${response.status} | Details: ${errorText}`;
      console.error(errorMessage);
      toast({
        variant: "destructive",
        title: "Scan Failed",
        description: errorText || `HTTP error! status: ${response.status}`,
      });
      throw new Error(errorMessage);
    }

    const data = await response.json();
    console.log("Scan response:", data);
    setCurrentScanId(scan_id);
    setCurrentScanStatus("in_progress");
    toast({
      title: "Scan Started",
      description: "Your scan has started successfully.",
    });
  } catch (error) {
    console.error("Error starting scan:", error);
    toast({
      variant: "destructive",
      title: "Scan Failed",
      description: "Unable to start scan.",
    });
  } finally {
    setIsLoading(false);
  }
};

// ...all other functions...

return (
  <>
    <div>
        {savedUrls.length > 0 && (
          <div className="mb-6">
            <h3 className="text-sm font-medium text-cyber-muted mb-3">
              Select from your saved URLs:
            </h3>
            <RadioGroup
              value={selectedUrl || ""}
              onValueChange={setSelectedUrl}
            >
              {savedUrls.map((savedUrl, index) => (
                <div className="flex items-center space-x-2 mb-2" key={index}>
                  <RadioGroupItem value={savedUrl} id={`url-${index}`} />
                  <Label htmlFor={`url-${index}`} className="cursor-pointer">
                    {savedUrl}
                  </Label>
                </div>
              ))}
            </RadioGroup>
          </div>
        )}
        <div className="mb-4">
          <h3 className="text-sm font-medium text-cyber-muted mb-2">
            {savedUrls.length > 0
              ? "Or enter a new URL:"
              : "Enter a website URL:"}
          </h3>
          <div className="flex gap-3 mb-2">
            <Input
              placeholder="https://example.com"
              value={url}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                setUrl(e.target.value);
                setSelectedUrl(null); // Clear selection when typing
              }}
              className="bg-cyber-dark/60 border-cyber-neon/30 text-cyber-text flex-grow"
            />
            <Button
              onClick={startScan}
              // ... (rest of the code remains the same)
              className="bg-gradient-to-r from-cyber-blue to-cyber-purple hover:from-cyber-purple hover:to-cyber-blue"
            >
              {isLoading ? (
                <Loader className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <Shield className="mr-2 h-4 w-4" />
              )}
              Scan Website
            </Button>
          </div>
          <p className="text-xs text-cyber-muted">
            Full scans typically take 5-10 minutes depending on site complexity.
          </p>
        </div>

        {currentScanId && currentScanStatus === "in_progress" && (
          <Card className="mb-8 p-6 border border-cyber-purple/20 bg-cyber-dark/60">
            <div className="mb-4">
              <h2 className="text-lg font-bold mb-2">
                Current Scan in Progress
              </h2>
              <p className="text-sm text-cyber-muted">
                Scan ID: {currentScanId}
              </p>
            </div>

            <Progress value={scanProgress} className="h-2 mb-4" />
            <div className="flex justify-between text-xs text-cyber-muted mb-4">
              <span>Status: In Progress</span>
              <span>{scanProgress}% complete</span>
            </div>

            <div className="flex justify-end">
              <Button
                onClick={checkScanStatus}
                disabled={isCheckingStatus}
                variant="outline"
                size="sm"
                className="border-cyber-neon/30"
              >
                {isCheckingStatus ? (
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                ) : null}
                Refresh Status
              </Button>
            </div>
          </Card>
        )}

        {completedScans.length > 0 && (
          <div>
            <h2 className="text-xl font-bold mb-4">Completed Scans</h2>
            <div className="overflow-x-auto">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>URL</TableHead>
                    <TableHead>Completed</TableHead>
                    <TableHead>Vulnerabilities</TableHead>
                    <TableHead className="text-right">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {completedScans.map((scan) => {
                    return (
                      <TableRow key={scan.id}>
                        <TableCell className="font-medium">
                          {scan.target_url}
                        </TableCell>
                        <TableCell>
                          {new Date(
                            scan.completed_at || scan.updated_at,
                          ).toLocaleString()}
                        </TableCell>
                        <TableCell>
                          <div className="flex gap-2">
                            {scanVulnCounts[scan.id]?.high > 0 && (
                              <span className="text-xs px-2 py-0.5 rounded-full bg-red-950/20 text-red-500">
                                {scanVulnCounts[scan.id].high} High
                              </span>
                            )}
                            {scanVulnCounts[scan.id]?.medium > 0 && (
                              <span className="text-xs px-2 py-0.5 rounded-full bg-orange-950/20 text-orange-500">
                                {scanVulnCounts[scan.id].medium} Med
                              </span>
                            )}
                            {scanVulnCounts[scan.id]?.low > 0 && (
                              <span className="text-xs px-2 py-0.5 rounded-full bg-yellow-950/20 text-yellow-500">
                                {scanVulnCounts[scan.id].low} Low
                              </span>
                            )}
                            {scanVulnCounts[scan.id]?.informational > 0 && (
                              <span className="text-xs px-2 py-0.5 rounded-full bg-blue-950/20 text-blue-500">
                                {scanVulnCounts[scan.id].informational} Info
                              </span>
                            )}
                            {scanVulnCounts[scan.id]?.total === 0 && (
                              <span className="text-xs px-2 py-0.5 rounded-full bg-green-950/20 text-green-500">
                                No issues
                              </span>
                            )}
                            {scanVulnCounts[scan.id] === undefined && (
                              <span className="text-xs text-cyber-muted">
                                ...
                              </span>
                            )}
                          </div>
                        </TableCell>
                        <TableCell className="text-right">
                          <div className="flex items-center gap-2">
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={() => viewScanDetails(scan.id)}
                            >
                              View Report
                            </Button>
                            {/* PDF Download Button */}
                            <DownloadPdfButton scanId={scan.id} />
                            {scan.report_path && (
                              <Button
                                variant="outline"
                                size="sm"
                                onClick={async () => {
                                  try {
                                    const { data: signedData, error: signedError } =
                                      await supabase.storage
                                        .from("scan_reports")
                                        .createSignedUrl(scan.report_path, 60);
                                    if (signedError || !signedData?.signedUrl) throw signedError || new Error('No signed URL');
                                    const resp = await fetch(signedData.signedUrl);
                                    const blob = await resp.blob();
                                    const url = window.URL.createObjectURL(blob);
                                    const a = document.createElement("a");
                                    a.href = url;
                                    a.download = `vulnerability-report-${scan.id}.json`;
                                    document.body.appendChild(a);
                                    a.click();
                                    window.URL.revokeObjectURL(url);
                                    document.body.removeChild(a);
                                    toast({
                                      title: "Success",
                                      description: "Report downloaded successfully",
                                    });
                                  } catch (error) {
                                    console.error("Error downloading report:", error);
                                    toast({
                                      variant: "destructive",
                                      title: "Error",
                                      description: "Failed to download report",
                                    });
                                  }
                                }}
                              >
                                Download Report
                              </Button>
                            )}
                          </div>
                        </TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </div>

            {/* --- Debug: List all scan report files in storage --- */}
            <div className="mt-8 p-4 rounded bg-cyber-dark/40 border border-cyber-purple/30">
              <h3 className="font-bold mb-2">Available Scan Report Files in Storage</h3>
              <Button size="sm" variant="outline" className="mb-2" onClick={fetchStorageFiles}>
                Refresh List
              </Button>
              <ul className="text-xs max-h-40 overflow-y-auto">
                {storageFiles.map(name => (
                  <li key={name}>
                    <a
                      href={`/report/${name.replace(/^scan-(.+)\.json$/, '$1')}`}
                      className="text-cyber-neon hover:underline"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      {name}
                    </a>
                  </li>
                ))}
              </ul>
            </div>

            {/* --- Cleanup: Find mismatches between DB and Storage --- */}
            <div className="mt-4">
              <Button size="sm" variant="outline" onClick={() => { setShowCleanup(true); runCleanup(); }}>
                Run Cleanup Check
              </Button>
              {showCleanup && (
                <ul className="mt-2 text-xs">
                  {cleanupResults.map((r, i) => (
                    <li key={i}>{r}</li>
                  ))}
                </ul>
              )}
            </div>
          </div>
        )}

        {!completedScans.length && !currentScanId && (
          <div className="text-center p-12 border border-dashed border-cyber-muted/30 rounded-xl">
            <Shield size={48} className="mx-auto mb-4 text-cyber-muted/50" />
            <h3 className="text-xl font-medium mb-2">No Scans Yet</h3>
            <p className="text-cyber-muted">
              Select a URL above to start your first security scan.
            </p>
          </div>
        )}
      </div>
      <Footer />
    </>
  );
};
export default VulnerabilityScanner;
