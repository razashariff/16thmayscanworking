import React, { useState, useEffect } from "react";
import { supabase } from "../integrations/supabase/client";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";

const bucket = "scan_reports";

const NewVulnerabilityScan: React.FC = () => {
  const [urls, setUrls] = useState<string[]>([]);
  const [selectedUrl, setSelectedUrl] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string>("");
  const [reportHtml, setReportHtml] = useState<string>("");
  const [scanId, setScanId] = useState<string | null>(null);
  const [scanStatus, setScanStatus] = useState<string>("");

  // Fetch URLs from previous scans
  useEffect(() => {
    const fetchUrls = async () => {
      const { data, error } = await supabase
        .from("vulnerability_scans")
        .select("target_url")
        .order("created_at", { ascending: false });
      if (error) {
        setError("Failed to fetch URLs");
        return;
      }
      const uniqueUrls = [
        ...new Set((data || []).map((item: any) => item.target_url)),
      ];
      setUrls(uniqueUrls);
      if (uniqueUrls.length > 0) setSelectedUrl(uniqueUrls[0]);
    };
    fetchUrls();
  }, []);

  // Start a new scan
  const handleStartScan = async () => {
    setIsLoading(true);
    setError("");
    setReportHtml("");
    setScanId(null);
    setScanStatus("");
    try {
      // Generate a unique scan_id for this scan
      const scan_id = (window.crypto && window.crypto.randomUUID) ? window.crypto.randomUUID() : Date.now().toString();
      const payload = { target_url: selectedUrl, scan_id };
      // Get user access token
      const session = await supabase.auth.getSession();
      const accessToken = session.data.session?.access_token;
      // Send the request to the Edge Function using fetch directly
      const response = await fetch(
        "https://jjdzrxfriezvfxjacche.supabase.co/functions/v1/zap-scan",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${accessToken}`,
            apikey: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpqZHpyeGZyaWV6dmZ4amFjY2hlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ4ODIyMjcsImV4cCI6MjA2MDQ1ODIyN30.gx3n1fKedtU4s4OqKIqPWvUlBQzajOz80rJit1STFwY",
          },
          body: JSON.stringify(payload),
        },
      );
      if (!response.ok) {
        const errorText = await response.text();
        setError(errorText || `HTTP error! status: ${response.status}`);
        setIsLoading(false);
        return;
      }
      const data = await response.json();
      setScanId(scan_id);
      setScanStatus("started");
      pollScanReportFile(scan_id);
    } catch (err) {
      setError("Unexpected error starting scan");
      setIsLoading(false);
    }
  };

  // Poll storage for report file containing this scanId
  const pollScanReportFile = async (scanId: string) => {
    let attempts = 0;
    const interval = setInterval(async () => {
      attempts++;
      if (attempts > 60) {
        setError("Scan timed out");
        setIsLoading(false);
        clearInterval(interval);
        return;
      }
      // List files in 'scans/' folder
      const { data: files, error: listError } = await supabase.storage
        .from(bucket)
        .list("scans/", { limit: 200 });
      if (listError || !files || files.length === 0) {
        return; // keep polling
      }
      // Find the latest .json file by created_at or filename
      const jsonFiles = files.filter(f => f.name.endsWith('.json'));
      if (jsonFiles.length > 0) {
        // Sort by created_at or by filename (lexicographically, which works for ISO timestamps)
        jsonFiles.sort((a, b) => (a.created_at || a.name).localeCompare(b.created_at || b.name));
        const latestFile = jsonFiles[jsonFiles.length - 1];
        clearInterval(interval);
        setScanStatus("completed");
        fetchAndDisplayReportByFile(latestFile.name);
      }
    }, 3000);
  };

  // Fetch and display the report by file name
  const fetchAndDisplayReportByFile = async (fileName: string) => {
    setIsLoading(true);
    setError("");
    try {
      const filePath = `scans/${fileName}`;
      const { data: urlData, error: urlError } = await supabase.storage
        .from(bucket)
        .createSignedUrl(filePath, 60);
      if (urlError || !urlData) {
        setError("Failed to get signed URL for report.");
        setIsLoading(false);
        return;
      }
      if (fileName.endsWith(".html")) {
        const resp = await fetch(urlData.signedUrl);
        const html = await resp.text();
        setReportHtml(html);
      } else if (fileName.endsWith(".json")) {
        const resp = await fetch(urlData.signedUrl);
        const json = await resp.json();
        setReportHtml(`<pre>${JSON.stringify(json, null, 2)}</pre>`);
      } else {
        setReportHtml(`<a href="${urlData.signedUrl}" target="_blank">Download Report</a>`);
      }
      setIsLoading(false);
    } catch (err) {
      setError("Error fetching report");
      setIsLoading(false);
    }
  };


  // Fetch and display the HTML report
  const fetchAndDisplayReport = async (scanId: string) => {
    setIsLoading(true);
    setError("");
    try {
      // List files in scans/ folder
      const { data: files, error: listError } = await supabase.storage
        .from(bucket)
        .list("scans/", { limit: 200 });
      if (listError || !files || files.length === 0) {
        setError("No scan reports found.");
        setIsLoading(false);
        return;
      }
      // Find the latest .html file for this scan
      const htmlFiles = files.filter(f => f.name.endsWith(".html") && f.name.includes(scanId));
      if (htmlFiles.length === 0) {
        setError("No HTML report found for this scan.");
        setIsLoading(false);
        return;
      }
      // Use the first (should be only) match
      const filePath = `scans/${htmlFiles[0].name}`;
      const { data: urlData, error: urlError } = await supabase.storage
        .from(bucket)
        .createSignedUrl(filePath, 60);
      if (urlError || !urlData) {
        setError("Failed to get signed URL for report.");
        setIsLoading(false);
        return;
      }
      // Fetch and display HTML
      const resp = await fetch(urlData.signedUrl);
      const html = await resp.text();
      setReportHtml(html);
      setIsLoading(false);
    } catch (err) {
      setError("Error fetching HTML report");
      setIsLoading(false);
    }
  };

  return (
    <div style={{ maxWidth: 700, margin: "2rem auto", background: "#23262F", borderRadius: 12, boxShadow: "0 2px 16px #0003", padding: "2rem" }}>
      <h1 style={{ color: "#ececec" }}>New Vulnerability Scan</h1>
      <div style={{ marginBottom: "1.5rem" }}>
        <RadioGroup value={selectedUrl} onValueChange={setSelectedUrl}>
          {urls.map((url) => (
            <div key={url} style={{ marginBottom: 8, display: "flex", alignItems: "center" }}>
              <RadioGroupItem value={url} id={url} />
              <Label htmlFor={url} style={{ color: "#ececec", marginLeft: 8 }}>{url}</Label>
            </div>
          ))}
        </RadioGroup>
      </div>
      <Button onClick={handleStartScan} disabled={isLoading || !selectedUrl} style={{ marginBottom: 16 }}>
        {isLoading ? "Scanning..." : "Start Vulnerability Scan"}
      </Button>
      {error && <div style={{ color: "#ff6b81", marginTop: 16 }}>{error}</div>}
      {reportHtml && (
        <div className="report" style={{ marginTop: 32, background: "#181A20", borderRadius: 8, padding: 16 }}>
          <h3 style={{ color: "#aaffcc" }}>Scan HTML Report</h3>
          <div dangerouslySetInnerHTML={{ __html: reportHtml }} />
        </div>
      )}
    </div>
  );
};

export default NewVulnerabilityScan;
