from zapv2 import ZAPv2
import time
import uuid
import json
import os
from datetime import datetime

# Initialize ZAP
zap = ZAPv2(proxies={'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'})

# Store scan statuses
active_scans = {}

# Create reports directory if it doesn't exist
REPORTS_DIR = os.path.join(os.path.dirname(__file__), 'reports')
os.makedirs(REPORTS_DIR, exist_ok=True)

def generate_report(scan_id: str, target_url: str, results: dict) -> str:
    """
    Generate a report for a completed scan
    
    Args:
        scan_id: ID of the scan
        target_url: URL that was scanned
        results: Dictionary with scan results
        
    Returns:
        report_path: Path to the generated report file
    """
    try:
        # Create report filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_filename = f'zap_report_{scan_id}_{timestamp}.txt'
        report_path = os.path.join(REPORTS_DIR, report_filename)
        
        with open(report_path, 'w') as f:
            # Write report header
            f.write('=' * 80 + '\n')
            f.write('ZAP Security Scan Report\n')
            f.write('=' * 80 + '\n\n')
            
            # Write scan information
            f.write('Scan Information:\n')
            f.write('-' * 40 + '\n')
            f.write(f'Target URL: {target_url}\n')
            f.write(f'Scan Date: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\n')
            f.write(f'Scan ID: {scan_id}\n\n')
            
            # Write summary
            f.write('Summary:\n')
            f.write('-' * 40 + '\n')
            for risk_level in ['high', 'medium', 'low', 'informational']:
                count = len(results.get(risk_level, []))
                f.write(f'{risk_level.capitalize()} Risk Issues: {count}\n')
            f.write('\n')
            
            # Write detailed findings
            f.write('Detailed Findings:\n')
            f.write('=' * 80 + '\n\n')
            
            for risk_level in ['high', 'medium', 'low', 'informational']:
                issues = results.get(risk_level, [])
                if issues:
                    f.write(f'{risk_level.upper()} RISK ISSUES\n')
                    f.write('-' * 40 + '\n\n')
                    
                    for i, issue in enumerate(issues, 1):
                        f.write(f'Issue {i}: {issue["name"]}\n')
                        f.write('-' * 40 + '\n')
                        f.write(f'Description: {issue["description"]}\n')
                        f.write(f'URL: {issue["url"]}\n')
                        if issue.get('param'):
                            f.write(f'Parameter: {issue["param"]}\n')
                        f.write(f'Solution: {issue["solution"]}\n\n')
            
            # Write recommendations
            f.write('Recommendations:\n')
            f.write('=' * 80 + '\n')
            f.write('1. Address all high and critical risk issues immediately\n')
            f.write('2. Review and fix medium risk issues as soon as possible\n')
            f.write('3. Consider addressing low risk issues in future updates\n')
            f.write('4. Use the informational findings to improve security awareness\n')
            f.write('5. Schedule regular security scans to maintain security posture\n\n')
            
            # Write footer
            f.write('=' * 80 + '\n')
            f.write('Report generated by ZAP Security Scanner\n')
            f.write('=' * 80 + '\n')
        
        return report_path
    
    except Exception as e:
        print(f'Error generating report: {str(e)}')
        raise Exception(f"Failed to generate report: {str(e)}")

def start_scan(target_url: str, scan_type: str = "full"):
    """
    Start a new ZAP scan
    
    Args:
        target_url: URL to scan
        scan_type: Type of scan (spider or full)
        
    Returns:
        scan_id: Unique ID for this scan
    """
    # Create unique scan ID if not provided
    scan_id = str(uuid.uuid4())
    
    try:
        # Configure ZAP
        print(f'Accessing target {target_url}')
        zap.urlopen(target_url)
        zap.core.new_session()
        
        # Spider scan
        print('Starting Spider scan')
        spider_id = zap.spider.scan(target_url)
        
        # Store scan information
        active_scans[scan_id] = {
            "type": scan_type,
            "progress": 0,
            "status": "spider_running",
            "target": target_url,
            "results": None,
            "spider_id": spider_id
        }
        
        # For full scans, we'll add active scan information later
        if scan_type == "full":
            active_scans[scan_id]["ascan_id"] = None
        
        return scan_id
    
    except Exception as e:
        print(f'Error during scan initialization: {str(e)}')
        raise Exception(f"Failed to start scan: {str(e)}")

def get_scan_status(scan_id: str):
    """
    Get the status of a scan
    
    Args:
        scan_id: ID of the scan
        
    Returns:
        status: Dictionary with scan status information
    """
    if scan_id not in active_scans:
        raise Exception(f"Scan not found: {scan_id}")
    
    scan_info = active_scans[scan_id]
    
    try:
        # Check spider progress
        if scan_info["status"] == "spider_running":
            spider_id = scan_info.get("spider_id", "1")
            progress = int(zap.spider.status(spider_id))
            scan_info["progress"] = progress
            
            if progress >= 100:
                print(f"Spider completed for scan {scan_id}")
                scan_info["status"] = "spider_completed"
                
                # For full scans, start the active scanner
                if scan_info["type"] == "full":
                    print(f"Starting active scan for {scan_id}")
                    # Wait for passive scan to complete
                    time.sleep(2)
                    ascan_id = zap.ascan.scan(scan_info["target"])
                    scan_info["ascan_id"] = ascan_id
                    scan_info["status"] = "active_scan_running"
                else:
                    # For spider-only scans, we're done
                    scan_info["status"] = "completed"
                    scan_info["results"] = get_scan_results(scan_info["target"], scan_id)
        
        # Check active scan progress if applicable
        elif scan_info["status"] == "active_scan_running":
            if scan_info.get("ascan_id") is None:
                # If active scan ID is missing, start the active scan
                ascan_id = zap.ascan.scan(scan_info["target"])
                scan_info["ascan_id"] = ascan_id
                scan_info["progress"] = 0
            else:
                # Get active scan progress
                ascan_id = scan_info["ascan_id"]
                progress = int(zap.ascan.status(ascan_id))
                scan_info["progress"] = progress
                
                if progress >= 100:
                    print(f"Active scan completed for {scan_id}")
                    scan_info["status"] = "completed"
                    scan_info["results"] = get_scan_results(scan_info["target"], scan_id)
        
        return {
            "scan_id": scan_id,
            "progress": scan_info["progress"],
            "status": scan_info["status"],
            "results": scan_info["results"],
            "error": None
        }
    
    except Exception as e:
        print(f'Error getting scan status: {str(e)}')
        # Update scan status to failed
        scan_info["status"] = "failed"
        scan_info["error"] = str(e)
        
        return {
            "scan_id": scan_id,
            "progress": scan_info.get("progress", 0),
            "status": "failed",
            "results": None,
            "error": str(e)
        }

def get_scan_results(target_url, scan_id=None):
    """
    Get results from a completed scan
    
    Args:
        target_url: URL that was scanned
        scan_id: ID of the scan (optional)
        
    Returns:
        results: Dictionary with scan results
    """
    try:
        # Get alerts from ZAP
        alerts = zap.core.alerts(baseurl=target_url)
        
        # Organize results by risk level
        results = {
            "high": [],
            "medium": [],
            "low": [],
            "informational": []
        }
        
        for alert in alerts:
            risk = alert["risk"].lower()
            if risk in results:
                results[risk].append({
                    "name": alert["name"],
                    "description": alert["description"],
                    "url": alert["url"],
                    "param": alert["param"],
                    "solution": alert["solution"]
                })
        
        # Generate report if we have a scan ID
        if scan_id:
            report_path = generate_report(scan_id, target_url, results)
            results["report_path"] = scan_id  # Store only the scan ID, not the full path
        
        return results
    except Exception as e:
        print(f'Error getting scan results: {str(e)}')
        raise Exception(f"Failed to get scan results: {str(e)}")

def get_report_file(scan_id: str) -> str:
    """
    Get the report file for a scan
    
    Args:
        scan_id: ID of the scan
        
    Returns:
        report_path: Path to the report file
    """
    try:
        # Look for report file in reports directory
        for filename in os.listdir(REPORTS_DIR):
            if filename.startswith(f'zap_report_{scan_id}_'):
                return os.path.join(REPORTS_DIR, filename)
        
        raise Exception(f"No report found for scan {scan_id}")
    except Exception as e:
        print(f'Error getting report file: {str(e)}')
        raise Exception(f"Failed to get report file: {str(e)}")
